"""
Nodos del agente de chatbot inteligente para Signaware.
Cada nodo representa una etapa del procesamiento de conversaci√≥n.
"""

import os
import logging
from typing import Dict, Any
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

# Configurar logging
logger = logging.getLogger(__name__)


class ChatbotNodes:

    def __init__(self):
        """Inicializa los nodos y sus dependencias."""
        self.logger = logging.getLogger(__name__)

    def classify_intent_node(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Nodo para clasificar la intenci√≥n del usuario.

        Args:
            state: Estado actual del chatbot

        Returns:
            Dict con la intenci√≥n detectada
        """
        try:
            user_input = state.get("user_input", "")
            if not user_input:
                state["detected_intent"] = "GENERAL_QUERY"
                return state

            # Usar la instancia compartida del clasificador
            if hasattr(self, "intention_classifier"):
                classifier = self.intention_classifier
            else:
                # Fallback: crear nueva instancia si no est√° disponible
                from ..services.intention_classifier_service import (
                    IntentionClassifierService,
                )

                classifier = IntentionClassifierService()

            detected_intent = classifier.execute(user_input)

            state["detected_intent"] = detected_intent
            self.logger.info(f"Intenci√≥n detectada: {detected_intent}")

            return state

        except Exception as e:
            self.logger.error(f"Error en classify_intent_node: {e}")
            state["detected_intent"] = "GENERAL_QUERY"
            return state

    # Nodos espec√≠ficos por categor√≠a de intenci√≥n

    def hearing_aids_node(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Nodo especializado para consultas sobre aud√≠fonos con b√∫squeda web en tiempo real"""
        try:
            from ..providers.text_generation.text_generator_manager import (
                text_generator_manager,
            )
            from ..providers.web_search.web_search_provider import web_search_provider
            from ..providers.web_search.medical_news_provider import medical_news_provider

            user_input = state.get("user_input", "")

            # Extraer informaci√≥n de ubicaci√≥n y tipo de consulta del input del usuario
            location, specialty, search_type = self._extract_search_parameters(user_input)
            
            # Realizar b√∫squeda web en tiempo real
            search_results = web_search_provider.search_medical_centers(location, specialty)
            
            # Obtener noticias m√©dicas actualizadas
            news_results = medical_news_provider.get_latest_hearing_aid_news()  # Usa el valor por defecto
            
            # Generar prompt con informaci√≥n actualizada
            prompt = self._generate_hearing_aids_prompt(user_input, search_results, news_results, search_type)
            
            # Obtener el generador del estado o usar gemini por defecto
            generator = state.get("text_generator_model", "gemini")
            response = text_generator_manager.execute_generator(generator, prompt)
            state["response"] = response
            self._update_conversation_history(state, "HEARING_AIDS")

            return state

        except Exception as e:
            self.logger.error(f"Error en hearing_aids_node: {e}")
            state["response"] = (
                "¬°Ups! üòÖ No pude procesar tu consulta. ¬øMe lo preguntas de otra forma? üí™"
            )
            return state

    def _extract_search_parameters(self, user_input: str) -> tuple:
        """Extrae par√°metros de b√∫squeda del input del usuario"""
        import re
        
        # Ubicaci√≥n por defecto
        location = "Espa√±a"
        specialty = "aud√≠fonos"
        search_type = "centers"  # centers, advice, general
        
        # Detectar ubicaci√≥n
        location_patterns = [
            r"en\s+([A-Za-z√Ä-√ø\s]+?)(?:\s+centros?|\s+especialistas?|\s+cl√≠nicas?)",
            r"([A-Za-z√Ä-√ø\s]+?)\s+centros?",
            r"([A-Za-z√Ä-√ø\s]+?)\s+especialistas?"
        ]
        
        for pattern in location_patterns:
            match = re.search(pattern, user_input, re.IGNORECASE)
            if match:
                location = match.group(1).strip()
                break
        
        # Detectar tipo de consulta
        if any(word in user_input.lower() for word in ["consejo", "consejos", "mantenimiento", "cuidado", "limpiar", "limpieza"]):
            search_type = "advice"
        elif any(word in user_input.lower() for word in ["precio", "precios", "coste", "costo", "cu√°nto", "cuanto", "dinero"]):
            search_type = "prices"
        elif any(word in user_input.lower() for word in ["tecnolog√≠a", "tecnologia", "moderno", "avanzado", "bluetooth", "wifi", "app"]):
            search_type = "technology"
        elif any(word in user_input.lower() for word in ["adaptaci√≥n", "adaptacion", "adaptar", "nuevo", "primera vez"]):
            search_type = "adaptation"
        elif any(word in user_input.lower() for word in ["centro", "centros", "cl√≠nica", "clinica", "especialista", "doctor", "m√©dico", "medico"]):
            search_type = "centers"
        elif any(word in user_input.lower() for word in ["noticia", "noticias", "actualidad", "nuevo", "√∫ltimo", "ultimo"]):
            search_type = "news"
        
        return location, specialty, search_type

    def _generate_hearing_aids_prompt(self, user_input: str, search_results: Dict[str, Any], news_results: Dict[str, Any], search_type: str) -> str:
        """Genera un prompt espec√≠fico con informaci√≥n de b√∫squeda web y noticias m√©dicas"""
        
        # Preparar informaci√≥n de centros m√©dicos
        centers_info = ""
        if "centers" in search_results and search_results["centers"]:
            centers_info = "**üè• Centros M√©dicos Encontrados:**\n\n"
            for i, center in enumerate(search_results["centers"][:3], 1):
                emoji = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â"
                centers_info += f"{emoji} **{center.get('name', 'Centro')}**\n"
                if center.get('address'):
                    centers_info += f"üìç {center.get('address')}\n"
                if center.get('phone'):
                    centers_info += f"üìû {center.get('phone')}\n"
                if center.get('rating'):
                    centers_info += f"‚≠ê {center.get('rating')}/5\n"
                centers_info += "\n"
        
        # Informaci√≥n de fuente
        source_info = f"**üì° Fuente:** {search_results.get('source', 'B√∫squeda web')}"
        
        # Preparar informaci√≥n de noticias m√©dicas
        news_info = ""
        if "articles" in news_results and news_results["articles"]:
            news_info = "**üì∞ √öltimas Noticias M√©dicas:**\n\n"
            for i, article in enumerate(news_results["articles"][:2], 1):  # Top 2 noticias
                emoji = "üì∞" if i == 1 else "üìã"
                news_info += f"{emoji} **{article.get('title', 'Noticia')}**\n"
                if article.get('description'):
                    news_info += f"üìù {article.get('description')[:100]}...\n"
                news_info += "\n"
        
        # Consejos espec√≠ficos seg√∫n el tipo de consulta
        advice_info = ""
        if search_type == "advice":
            advice_info = medical_news_provider.get_medical_advice_by_topic("mantenimiento")
        elif search_type == "prices":
            advice_info = medical_news_provider.get_medical_advice_by_topic("precios")
        elif search_type == "technology":
            advice_info = medical_news_provider.get_medical_advice_by_topic("tecnolog√≠a")
        elif search_type == "adaptation":
            advice_info = medical_news_provider.get_medical_advice_by_topic("adaptaci√≥n")
        elif search_type == "news":
            advice_info = medical_news_provider.get_medical_trends()
        else:
            # Consejo general
            advice_info = "üí° **Consejo General:** Consulta con un especialista para informaci√≥n personalizada."
        
        prompt = f"""
        Eres un amigable especialista en aud√≠fonos que ayuda a personas con discapacidad auditiva.
        
        El usuario pregunta: "{user_input}"
        
        Responde de manera:
        - üéâ Alegre y motivadora
        - üìù Breve y f√°cil de entender (m√°ximo 4 l√≠neas)
        - üíù Amigable y emp√°tica
        - ‚ú® Con emojis y markdown para hacerlo m√°s atractivo
        
        Informaci√≥n actualizada encontrada:
        {centers_info}
        {source_info}
        {news_info}
        {advice_info}
        
        Da informaci√≥n pr√°ctica sobre:
        - Un centro m√©dico recomendado (si hay resultados)
        - Una noticia relevante (si hay noticias)
        - Un consejo √∫til espec√≠fico para su consulta
        - Un mensaje de apoyo y motivaci√≥n
        
        **Al final, agrega un dato curioso o tendencia actual** sobre aud√≠fonos que sea √∫til y motivador.
        
        ¬°S√© positivo y alentador! üí™
        """
        
        return prompt

    def medical_center_node(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Nodo especializado para centros m√©dicos y especialistas con b√∫squeda web en tiempo real"""
        try:
            from ..providers.text_generation.text_generator_manager import (
                text_generator_manager,
            )
            from ..providers.web_search.web_search_provider import web_search_provider
            from ..providers.web_search.medical_news_provider import medical_news_provider

            user_input = state.get("user_input", "")

            # Extraer informaci√≥n de especialidad y ubicaci√≥n del input del usuario
            self.logger.info(f"üîç Procesando consulta m√©dica: '{user_input}'")
            specialty, search_type, location = self._extract_medical_search_parameters(user_input)
            self.logger.info(f"üî¨ Especialidad detectada: '{specialty}', Tipo: '{search_type}', Ubicaci√≥n: '{location}'")
            
            # Realizar b√∫squeda web en tiempo real
            self.logger.info("üåê Iniciando b√∫squeda de centros m√©dicos...")
            search_results = web_search_provider.search_medical_centers(location=location, specialty=specialty)
            
            # Verificar si hay error en la b√∫squeda
            if "error" in search_results:
                self.logger.error(f"‚ùå Error en b√∫squeda: {search_results.get('error')}")
                state["response"] = f"¬°Ups! üòÖ {search_results.get('message', 'No se pudo completar la b√∫squeda.')} üí™"
                self._update_conversation_history(state, "MEDICAL_CENTER")
                return state
            
            self.logger.info(f"‚úÖ B√∫squeda completada. Fuente: {search_results.get('source', 'N/A')}, Centros encontrados: {search_results.get('total_results', 0)}")
            
            # Obtener noticias m√©dicas actualizadas
            self.logger.info("üì∞ Obteniendo noticias m√©dicas...")
            news_results = medical_news_provider.get_latest_hearing_aid_news(days=30)
            self.logger.info(f"‚úÖ Noticias obtenidas. Art√≠culos: {news_results.get('total_results', 0)}")
            
            # Generar prompt con informaci√≥n actualizada
            prompt = self._generate_medical_center_prompt(user_input, search_results, news_results, search_type)
            
            # Obtener el generador del estado o usar gemini por defecto
            generator = state.get("text_generator_model", "gemini")
            response = text_generator_manager.execute_generator(generator, prompt)
            state["response"] = response
            self._update_conversation_history(state, "MEDICAL_CENTER")

            return state

        except Exception as e:
            self.logger.error(f"Error en medical_center_node: {e}")
            state["response"] = (
                "¬°Ups! üòÖ No pude procesar tu consulta. ¬øMe lo preguntas de otra forma? üí™"
            )
            return state

    def _extract_medical_search_parameters(self, user_input: str) -> tuple:
        """Extrae par√°metros de b√∫squeda m√©dica del input del usuario"""
        import re
        
        specialty = "centros auditivos"
        search_type = "centers"  # centers, specialists, hospitals, clinics
        location = None  # Por defecto None (usar√° Barcelona)
        
        # Detectar especialidad m√©dica
        if any(word in user_input.lower() for word in ["otorrino", "otorrinolaring√≥logo", "otorrinolaringolog√≠a", "centro auditivo", "centros auditivos", "audici√≥n", "o√≠do", "oido"]):
            specialty = "centros auditivos"
        elif any(word in user_input.lower() for word in ["audi√≥logo", "audiolog√≠a", "aud√≠fonos", "audifonos"]):
            specialty = "audiolog√≠a"
        elif any(word in user_input.lower() for word in ["neur√≥logo", "neurolog√≠a", "nervio auditivo"]):
            specialty = "neurolog√≠a"
        elif any(word in user_input.lower() for word in ["pediatra", "pediatr√≠a", "ni√±os", "ni√±o", "infantil"]):
            specialty = "pediatr√≠a"
        elif any(word in user_input.lower() for word in ["geriatra", "geriatr√≠a", "mayores", "adultos mayores"]):
            specialty = "geriatr√≠a"
        
        # Detectar tipo de consulta
        if any(word in user_input.lower() for word in ["especialista", "doctor", "m√©dico", "medico"]):
            search_type = "specialists"
        elif any(word in user_input.lower() for word in ["hospital", "hospitales"]):
            search_type = "hospitals"
        elif any(word in user_input.lower() for word in ["cl√≠nica", "clinica", "centro m√©dico"]):
            search_type = "clinics"
        elif any(word in user_input.lower() for word in ["urgencias", "emergencia", "urgente"]):
            search_type = "emergency"
        elif any(word in user_input.lower() for word in ["revisi√≥n", "revision", "consulta", "cita"]):
            search_type = "appointment"
        else:
            search_type = "centers"
        
        # Detectar ubicaci√≥n espec√≠fica
        location_patterns = [
            r"en\s+([A-Za-z√Ä-√ø\s]+?)(?:\s+centros?|\s+especialistas?|\s+cl√≠nicas?|\s+hospitales?|\s+centro)",
            r"busca\s+(?:centros?|especialistas?|cl√≠nicas?|hospitales?)\s+en\s+([A-Za-z√Ä-√ø\s]+)",
            r"centros?\s+en\s+([A-Za-z√Ä-√ø\s]+)",
            r"especialistas?\s+en\s+([A-Za-z√Ä-√ø\s]+)",
            r"cl√≠nicas?\s+en\s+([A-Za-z√Ä-√ø\s]+)",
            r"hospitales?\s+en\s+([A-Za-z√Ä-√ø\s]+)"
        ]
        
        for pattern in location_patterns:
            match = re.search(pattern, user_input, re.IGNORECASE)
            if match:
                location = match.group(1).strip()
                self.logger.info(f"üìç Ubicaci√≥n detectada: '{location}'")
                break
        
        return specialty, search_type, location

    def _generate_medical_center_prompt(self, user_input: str, search_results: Dict[str, Any], news_results: Dict[str, Any], search_type: str) -> str:
        """Genera un prompt espec√≠fico para centros m√©dicos con informaci√≥n de b√∫squeda web"""
        
        # Preparar informaci√≥n de centros m√©dicos
        centers_info = ""
        if "centers" in search_results and search_results["centers"]:
            centers_info = "**üè• Centros M√©dicos M√°s Cercanos:**\n\n"
            for i, center in enumerate(search_results["centers"][:5], 1):
                emoji = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else "4Ô∏è‚É£" if i == 4 else "5Ô∏è‚É£"
                centers_info += f"{emoji} **{center.get('name', 'Centro')}**\n"
                if center.get('address'):
                    centers_info += f"üìç {center.get('address')}\n"
                if center.get('phone'):
                    centers_info += f"üìû {center.get('phone')}\n"
                if center.get('website'):
                    centers_info += f"üåê {center.get('website')}\n"
                if center.get('google_maps_url'):
                    centers_info += f"üó∫Ô∏è [Ver en Google Maps]({center.get('google_maps_url')})\n"
                if center.get('rating'):
                    centers_info += f"‚≠ê {center.get('rating')}/5 ({center.get('reviews_count', 0)} rese√±as)\n"
                centers_info += "\n"
        
        # Informaci√≥n de fuente
        source_info = f"**üì° Fuente:** {search_results.get('source', 'B√∫squeda web')}"
        
        # Preparar informaci√≥n de noticias m√©dicas
        news_info = ""
        if "articles" in news_results and news_results["articles"]:
            news_info = "**üì∞ √öltimas Noticias M√©dicas:**\n\n"
            for i, article in enumerate(news_results["articles"][:2], 1):  # Top 2 noticias
                emoji = "üì∞" if i == 1 else "üìã"
                news_info += f"{emoji} **{article.get('title', 'Noticia')}**\n"
                if article.get('description'):
                    news_info += f"üìù {article.get('description')[:100]}...\n"
                news_info += "\n"
        
        # Consejos espec√≠ficos seg√∫n el tipo de consulta
        advice_info = ""
        if search_type == "specialists":
            advice_info = """
            **üë®‚Äç‚öïÔ∏è Consejos para Especialistas:**
            ‚Ä¢ Busca otorrinolaring√≥logos certificados
            ‚Ä¢ Pregunta por experiencia en tu caso espec√≠fico
            ‚Ä¢ Consulta opiniones de otros pacientes
            ‚Ä¢ Verifica que acepte tu seguro m√©dico
            """
        elif search_type == "hospitals":
            advice_info = """
            **üè• Consejos para Hospitales:**
            ‚Ä¢ Lleva tu historial m√©dico completo
            ‚Ä¢ Pregunta por especialistas en audici√≥n
            ‚Ä¢ Verifica horarios de atenci√≥n
            ‚Ä¢ Ten preparados tus documentos de identidad
            """
        elif search_type == "clinics":
            advice_info = """
            **üè• Consejos para Cl√≠nicas:**
            ‚Ä¢ Compara precios entre varias cl√≠nicas
            ‚Ä¢ Pregunta por equipos de diagn√≥stico
            ‚Ä¢ Verifica si tienen servicio de urgencias
            ‚Ä¢ Consulta por opciones de financiaci√≥n
            """
        elif search_type == "emergency":
            advice_info = """
            **üö® Consejos para Urgencias:**
            ‚Ä¢ Ve al hospital m√°s cercano
            ‚Ä¢ Lleva identificaci√≥n y tarjeta sanitaria
            ‚Ä¢ Explica claramente tus s√≠ntomas
            ‚Ä¢ Pide que te deriven a un especialista
            """
        elif search_type == "appointment":
            advice_info = """
            **üìÖ Consejos para Citas:**
            ‚Ä¢ Llama con anticipaci√≥n para programar
            ‚Ä¢ Ten lista tu informaci√≥n m√©dica
            ‚Ä¢ Lleva estudios previos si los tienes
            ‚Ä¢ Pregunta por la duraci√≥n de la consulta
            """
        else:
            advice_info = """
            **üí° Consejo General:**
            ‚Ä¢ Busca centros con buena reputaci√≥n
            ‚Ä¢ Verifica que tengan especialistas en audici√≥n
            ‚Ä¢ Compara opciones antes de decidir
            ‚Ä¢ Consulta por opciones de pago
            """
        
        prompt = f"""
        Eres un amigable especialista en salud auditiva que ayuda a personas con discapacidad auditiva.
        
        El usuario pregunta: "{user_input}"
        
        Responde de manera:
        - üéâ Alegre y motivadora
        - üìù Breve y f√°cil de entender
        - üíù Amigable y emp√°tica
        - ‚ú® Con emojis y markdown para hacerlo m√°s atractivo
        
        Informaci√≥n actualizada encontrada:
        {centers_info}
        {source_info}
        {news_info}
        {advice_info}
        
        **IMPORTANTE:** Si hay centros m√©dicos encontrados, muestra SOLO:
        - Nombre del centro
        - Ubicaci√≥n/direcci√≥n
        - P√°gina web (si est√° disponible)
        
        No incluyas tel√©fonos ni puntuaciones en la respuesta principal.
        
        Da informaci√≥n pr√°ctica sobre:
        - Los centros m√©dicos encontrados (nombre, ubicaci√≥n, web)
        - Un consejo √∫til para la consulta
        - Un mensaje de apoyo
        
        ¬°S√© positivo y alentador! üí™
        """
        
        return prompt

    def medical_news_node(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Nodo especializado para noticias m√©dicas y actualidad en salud auditiva"""
        try:
            from ..providers.text_generation.text_generator_manager import (
                text_generator_manager,
            )
            from ..providers.web_search.medical_news_provider import medical_news_provider

            user_input = state.get("user_input", "")

            # Extraer par√°metros de b√∫squeda de noticias
            self.logger.info(f"üì∞ Procesando consulta de noticias: '{user_input}'")
            news_type, days = self._extract_news_parameters(user_input)
            self.logger.info(f"üì∞ Tipo de noticia: '{news_type}', D√≠as: {days}")

            # Obtener noticias m√©dicas actualizadas
            self.logger.info("üì∞ Obteniendo noticias m√©dicas...")
            if news_type == "hearing_aids":
                news_results = medical_news_provider.get_latest_hearing_aid_news(days=days)
            elif news_type == "research":
                news_results = medical_news_provider.get_medical_research_news(days=days)
            elif news_type == "technology":
                news_results = medical_news_provider.get_medical_technology_news(days=days)
            else:
                news_results = medical_news_provider.get_latest_hearing_aid_news(days=days)

            self.logger.info(f"‚úÖ Noticias obtenidas. Art√≠culos: {news_results.get('total_results', 0)}")

            # Verificar si hay error en los resultados
            if "error" in news_results:
                self.logger.error(f"‚ùå Error en noticias: {news_results.get('message', 'Error desconocido')}")
                # Generar respuesta amigable cuando no hay noticias disponibles
                prompt = self._generate_medical_news_fallback_prompt(user_input, news_results, news_type)
            else:
                # Generar prompt con informaci√≥n de noticias
                prompt = self._generate_medical_news_prompt(user_input, news_results, news_type)

            # Obtener el generador del estado o usar gemini por defecto
            generator = state.get("text_generator_model", "gemini")
            response = text_generator_manager.execute_generator(generator, prompt)
            state["response"] = response
            self._update_conversation_history(state, "MEDICAL_NEWS")

            return state

        except Exception as e:
            self.logger.error(f"Error en medical_news_node: {e}")
            state["response"] = (
                "¬°Ups! üòÖ No pude procesar tu consulta de noticias. ¬øMe lo preguntas de otra forma? üí™"
            )
            return state

    def _extract_news_parameters(self, user_input: str) -> tuple:
        """Extrae par√°metros de b√∫squeda de noticias del input del usuario"""
        import re
        
        news_type = "hearing_aids"  # hearing_aids, research, technology
        days = 30  # Por defecto 30 d√≠as (l√≠mite del plan gratuito de News API)
        
        # Detectar tipo de noticia
        if any(word in user_input.lower() for word in ["investigaci√≥n", "investigacion", "estudio", "estudios", "investigar"]):
            news_type = "research"
        elif any(word in user_input.lower() for word in ["tecnolog√≠a", "tecnologia", "avances", "innovaci√≥n", "innovacion", "nuevo", "nuevos"]):
            news_type = "technology"
        elif any(word in user_input.lower() for word in ["aud√≠fonos", "audifonos", "audici√≥n", "audicion", "o√≠do", "oido"]):
            news_type = "hearing_aids"
        
        # Detectar per√≠odo de tiempo
        if "√∫ltimos" in user_input.lower() or "last" in user_input.lower():
            days_match = re.search(r"(\d+)\s*d√≠as?", user_input.lower())
            if days_match:
                days = int(days_match.group(1))
        elif "hoy" in user_input.lower() or "today" in user_input.lower():
            days = 1
        elif "semana" in user_input.lower() or "week" in user_input.lower():
            days = 7
        elif "mes" in user_input.lower() or "month" in user_input.lower():
            days = 30
        elif "trimestre" in user_input.lower() or "quarter" in user_input.lower():
            days = 90
        elif "a√±o" in user_input.lower() or "year" in user_input.lower():
            days = 365
        
        return news_type, days

    def _generate_medical_news_prompt(self, user_input: str, news_results: Dict[str, Any], news_type: str) -> str:
        """Genera un prompt espec√≠fico para noticias m√©dicas"""
        
        # Preparar informaci√≥n de noticias
        news_info = ""
        if "articles" in news_results and news_results["articles"]:
            news_info = "**üì∞ √öltimas Noticias M√©dicas:**\n\n"
            for i, article in enumerate(news_results["articles"][:5], 1):  # Top 5 noticias
                emoji = "üì∞" if i == 1 else "üìã" if i == 2 else "üìÑ" if i == 3 else "üìù" if i == 4 else "üìå"
                news_info += f"{emoji} **{article.get('title', 'Noticia')}**\n"
                if article.get('description'):
                    news_info += f"üìù {article.get('description')[:150]}...\n"
                if article.get('source'):
                    news_info += f"üì° Fuente: {article.get('source')}\n"
                if article.get('published_at'):
                    news_info += f"üìÖ {article.get('published_at')}\n"
                news_info += "\n"
        
        # Informaci√≥n de fuente
        source_info = f"**üì° Fuente:** {news_results.get('source', 'B√∫squeda de noticias m√©dicas')}"
        
        # Consejos espec√≠ficos seg√∫n el tipo de noticia
        advice_info = ""
        if news_type == "research":
            advice_info = """
            **üî¨ Consejos sobre Investigaci√≥n:**
            ‚Ä¢ Mantente informado sobre los √∫ltimos avances
            ‚Ä¢ Consulta con tu especialista sobre nuevas opciones
            ‚Ä¢ Los estudios pueden abrir nuevas posibilidades de tratamiento
            """
        elif news_type == "technology":
            advice_info = """
            **‚ö° Consejos sobre Tecnolog√≠a:**
            ‚Ä¢ La tecnolog√≠a avanza r√°pidamente en aud√≠fonos
            ‚Ä¢ Pregunta por las √∫ltimas innovaciones disponibles
            ‚Ä¢ Considera actualizar tu dispositivo si es necesario
            """
        else:
            advice_info = """
            **üí° Consejo General:**
            ‚Ä¢ Mantente al d√≠a con las noticias m√©dicas
            ‚Ä¢ Consulta con profesionales sobre las novedades
            ‚Ä¢ La informaci√≥n actualizada puede mejorar tu tratamiento
            """
        
        prompt = f"""
        Eres un amigable especialista en salud auditiva que ayuda a personas con discapacidad auditiva.
        
        El usuario pregunta: "{user_input}"
        
        Responde de manera:
        - üéâ Alegre y motivadora
        - üìù Breve y f√°cil de entender
        - üíù Amigable y emp√°tica
        - ‚ú® Con emojis y markdown para hacerlo m√°s atractivo
        
        Informaci√≥n actualizada encontrada:
        {news_info}
        {source_info}
        {advice_info}
        
        Da informaci√≥n pr√°ctica sobre:
        - Las noticias m√°s relevantes encontradas
        - Un consejo √∫til basado en las noticias
        - Un mensaje de apoyo y motivaci√≥n
        
        ¬°S√© positivo y alentador! üí™
        """
        
        return prompt

    def _generate_medical_news_fallback_prompt(self, user_input: str, news_results: Dict[str, Any], news_type: str) -> str:
        """Genera un prompt de fallback cuando no hay noticias disponibles"""
        
        # Obtener informaci√≥n de tendencias y consejos
        from ..providers.web_search.medical_news_provider import medical_news_provider
        
        trends_info = medical_news_provider.get_medical_trends()
        
        # Consejos espec√≠ficos seg√∫n el tipo de noticia
        advice_info = ""
        if news_type == "research":
            advice_info = """
            **üî¨ Consejos sobre Investigaci√≥n:**
            ‚Ä¢ Mantente informado sobre los √∫ltimos avances
            ‚Ä¢ Consulta con tu especialista sobre nuevas opciones
            ‚Ä¢ Los estudios pueden abrir nuevas posibilidades de tratamiento
            """
        elif news_type == "technology":
            advice_info = """
            **‚ö° Consejos sobre Tecnolog√≠a:**
            ‚Ä¢ La tecnolog√≠a avanza r√°pidamente en aud√≠fonos
            ‚Ä¢ Pregunta por las √∫ltimas innovaciones disponibles
            ‚Ä¢ Considera actualizar tu dispositivo si es necesario
            """
        else:
            advice_info = """
            **üí° Consejo General:**
            ‚Ä¢ Mantente al d√≠a con las noticias m√©dicas
            ‚Ä¢ Consulta con profesionales sobre las novedades
            ‚Ä¢ La informaci√≥n actualizada puede mejorar tu tratamiento
            """
        
        # Informaci√≥n sobre el error
        error_message = news_results.get('message', 'No se pudieron obtener noticias actualizadas')
        
        prompt = f"""
        Eres un amigable especialista en salud auditiva que ayuda a personas con discapacidad auditiva.
        
        El usuario pregunta: "{user_input}"
        
        IMPORTANTE: No se encontraron noticias espec√≠ficas sobre aud√≠fonos en los √∫ltimos 30 d√≠as en las fuentes de noticias. Esto es normal porque las noticias sobre aud√≠fonos no son tan frecuentes como otros temas.
        
        Responde de manera:
        - üéâ Alegre y motivadora
        - üìù Breve y f√°cil de entender
        - üíù Amigable y emp√°tica
        - ‚ú® Con emojis y markdown para hacerlo m√°s atractivo
        
        IMPORTANTE: Debes decir claramente al usuario que no se encontraron noticias recientes sobre aud√≠fonos, pero que puedes compartir informaci√≥n √∫til sobre tendencias actuales.
        
        Estructura tu respuesta as√≠:
        1. **Explica claramente** que no hay noticias recientes sobre aud√≠fonos
        2. **Comparte tendencias actuales** en lugar de noticias
        3. **Da un consejo √∫til** para mantenerse informado
        4. **Mensaje de apoyo** positivo
        
        Informaci√≥n disponible:
        {trends_info}
        {advice_info}
        
        ¬°S√© positivo y alentador! üí™
        """
        
        return prompt

    def generate_image_node(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Nodo especializado para generaci√≥n de im√°genes usando Stable Diffusion"""
        try:
            from ..providers.image_generation.image_generator_manager import (
                image_generator_manager,
            )

            user_input = state.get("user_input", "")

            # Extraer par√°metros de generaci√≥n de imagen del input del usuario
            self.logger.info(f"üé® Procesando solicitud de imagen: '{user_input}'")
            image_type, description = self._extract_image_parameters(user_input)
            self.logger.info(f"üé® Tipo de imagen: '{image_type}', Descripci√≥n: '{description}'")

            # Generar prompt para la imagen
            prompt = self._generate_image_prompt(image_type, description, user_input)

            # Generar la imagen usando Stable Diffusion
            self.logger.info("üé® Iniciando generaci√≥n de imagen...")
            result = image_generator_manager.execute_generator("stable_diffusion", prompt)

            # Verificar si la generaci√≥n fue exitosa
            if not result.get("success", False):
                self.logger.error(f"‚ùå Error en generaci√≥n: {result.get('error', 'Error desconocido')}")
                state["response"] = f"¬°Ups! üòÖ {result.get('message', 'No se pudo generar la imagen.')} üí™"
                self._update_conversation_history(state, "GENERATE_IMAGE")
                return state

            # Obtener la imagen en base64
            image_base64 = result.get("image_base64")
            if not image_base64:
                state["response"] = "¬°Ups! üòÖ No se pudo generar la imagen. Intenta con otra descripci√≥n. üí™"
                self._update_conversation_history(state, "GENERATE_IMAGE")
                return state

            # Devolver objeto JSON con la estructura que espera el frontend
            response_obj = {
                "success": True,
                "image_base64": image_base64,
                "prompt": prompt,
                "parameters": result.get("parameters", {}),
                "format": "base64"
            }
            # Convertir el objeto a string JSON para que sea compatible con AIMessage
            import json
            state["response"] = json.dumps(response_obj)
            
            self.logger.info("‚úÖ Imagen generada exitosamente")
            self._update_conversation_history(state, "GENERATE_IMAGE")

            return state

        except Exception as e:
            self.logger.error(f"Error en generate_image_node: {e}")
            state["response"] = (
                "¬°Ups! üòÖ No pude generar la imagen. ¬øMe lo pides de otra forma? üí™"
            )
            return state

    def _extract_image_parameters(self, user_input: str) -> tuple:
        """Extrae par√°metros de generaci√≥n de imagen del input del usuario"""
        import re
        
        image_type = "general"  # general, medical, hearing_aid, illustration
        description = user_input
        
        # Detectar tipo de imagen
        if any(word in user_input.lower() for word in ["aud√≠fono", "audifono", "aud√≠fonos", "audifonos", "dispositivo auditivo"]):
            image_type = "hearing_aid"
            # Extraer descripci√≥n espec√≠fica del aud√≠fono
            hearing_patterns = [
                r"(?:aud√≠fono|audifono|dispositivo)\s+(.+?)(?:\s+por favor|\s+gracias|$)",
                r"genera\s+(?:un\s+)?(?:aud√≠fono|audifono|dispositivo)\s+(.+?)(?:\s+por favor|\s+gracias|$)",
                r"crea\s+(?:un\s+)?(?:aud√≠fono|audifono|dispositivo)\s+(.+?)(?:\s+por favor|\s+gracias|$)"
            ]
            for pattern in hearing_patterns:
                match = re.search(pattern, user_input, re.IGNORECASE)
                if match:
                    description = match.group(1).strip()
                    break
        elif any(word in user_input.lower() for word in ["m√©dico", "medico", "m√©dica", "medica", "anatom√≠a", "anatomia", "o√≠do", "oido", "oreja"]):
            image_type = "medical"
        elif any(word in user_input.lower() for word in ["ilustraci√≥n", "ilustracion", "diagrama", "esquema", "dibujo"]):
            image_type = "illustration"
        
        # Limpiar descripci√≥n
        description = re.sub(r'(?:genera|crea|dibuja|muestra)\s+', '', description, flags=re.IGNORECASE)
        description = re.sub(r'\s+(?:por favor|gracias|\.)$', '', description, flags=re.IGNORECASE)
        
        return image_type, description

    def _generate_image_prompt(self, image_type: str, description: str, user_input: str) -> str:
        """Genera un prompt optimizado para la generaci√≥n de im√°genes"""
        
        if image_type == "hearing_aid":
            return f"modern hearing aid device, {description}, professional product photography, clean background, high quality, detailed, realistic"
        elif image_type == "medical":
            return f"professional medical illustration, {description}, clean, detailed, educational, high quality, anatomical accuracy"
        elif image_type == "illustration":
            return f"professional illustration, {description}, clean, detailed, educational, high quality, artistic"
        else:
            return f"high quality image, {description}, clean, detailed, professional, realistic"

    def sound_report_node(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Nodo especializado para reportes y an√°lisis de sonidos"""
        try:
            from ..providers.text_generation.text_generator_manager import (
                text_generator_manager,
            )
            from ..services.sound_report_service import SoundReportService

            user_input = state.get("user_input", "")

            # Generar reporte de sonidos detectados
            sound_report_service = SoundReportService()

            # Extraer par√°metros del usuario (si los especifica)
            days = 1  # Por defecto 1 d√≠a (hoy)
            user_id = None  # Por defecto todos los usuarios

            # Buscar par√°metros en el input del usuario
            if "√∫ltimos" in user_input.lower() or "last" in user_input.lower():
                # Extraer n√∫mero de d√≠as si se especifica
                import re

                days_match = re.search(r"(\d+)\s*d√≠as?", user_input.lower())
                if days_match:
                    days = int(days_match.group(1))
            elif "hoy" in user_input.lower() or "today" in user_input.lower():
                days = 1
            elif "semana" in user_input.lower() or "week" in user_input.lower():
                days = 7
            elif "mes" in user_input.lower() or "month" in user_input.lower():
                days = 30

            # Generar reporte
            report = sound_report_service.generate_sound_report(
                user_id=user_id, days=days
            )

            if "error" in report:
                # Si hay error, generar respuesta amigable
                prompt = f"""
                Eres un amigable especialista en sonidos que ayuda a personas con discapacidad auditiva.
                
                El usuario pregunta: "{user_input}"
                
                Hubo un peque√±o problema t√©cnico, pero puedes ayudarle con informaci√≥n b√°sica.
                
                Responde de manera:
                - üéâ Alegre y motivadora
                - üìù Breve y f√°cil de entender
                - üíù Amigable y emp√°tica
                - ‚ú® Con emojis para hacerlo m√°s ameno
                
                Da informaci√≥n pr√°ctica sobre:
                - Una herramienta √∫til para detectar sonidos
                - Un consejo para estar m√°s seguro
                
                M√°ximo 3-4 l√≠neas. ¬°S√© positivo y alentador!
                """

                # Obtener el generador del estado o usar gemini por defecto
                generator = state.get("text_generator_model", "gemini")
                response = text_generator_manager.execute_generator(generator, prompt)
                state["response"] = response
                self._update_conversation_history(state, "SOUND_REPORT")

                return state

            # Generar prompt con datos del reporte
            prompt = self._generate_sound_report_prompt(user_input, report)

            # Obtener el generador del estado o usar gemini por defecto
            generator = state.get("text_generator_model", "gemini")
            response = text_generator_manager.execute_generator(generator, prompt)
            state["response"] = response
            self._update_conversation_history(state, "SOUND_REPORT")

            return state

        except Exception as e:
            self.logger.error(f"Error en sound_report_node: {e}")
            state["response"] = (
                "¬°Ups! üòÖ No pude procesar tu consulta. ¬øMe lo preguntas de otra forma? üí™"
            )
            return state

    def _generate_sound_report_prompt(
        self, user_input: str, report: Dict[str, Any]
    ) -> str:
        """Genera un prompt espec√≠fico para el reporte de sonidos"""

        # Preparar datos del reporte
        summary = report.get("summary", {})
        sound_stats = report.get("sound_type_statistics", [])
        critical_sounds = report.get("critical_sounds", [])
        recommendations = report.get("recommendations", [])
        period = report.get("period", {})

        # Datos principales
        total_detections = summary.get("total_detections", 0)
        days = period.get("days", 30)

        # Top 5 sonidos m√°s frecuentes
        top_sounds = ""
        if sound_stats:
            top_sounds = "**üéØ Top 5 Sonidos Detectados:**\n\n"
            for i, stat in enumerate(sound_stats[:5], 1):
                emoji = (
                    "ü•á"
                    if i == 1
                    else "ü•à" if i == 2 else "ü•â" if i == 3 else "4Ô∏è‚É£" if i == 4 else "5Ô∏è‚É£"
                )
                top_sounds += (
                    f"{emoji} **{stat['label']}**: `{stat['count']} veces`\n\n"
                )

        # Sonido cr√≠tico reciente
        critical_info = ""
        if critical_sounds:
            critical_info = (
                f"**üö® √öltima Alerta Cr√≠tica:** `{critical_sounds[0]['sound_type']}`"
            )

        # Recomendaci√≥n principal
        main_recommendation = ""
        if recommendations:
            main_recommendation = (
                f"**üí° Recomendaci√≥n Estrella:** > {recommendations[0]}"
            )

        prompt = f"""
        Eres un amigable especialista en sonidos que ayuda a personas con discapacidad auditiva.
        
        El usuario pregunta: "{user_input}"
        
        Responde de manera:
        - üéâ Alegre y motivadora
        - üìù Breve y directa (m√°ximo 3 l√≠neas)
        - üíù Amigable y emp√°tica
        - ‚ú® Con emojis y markdown para hacerlo m√°s atractivo
        
        Usa markdown para darle vida:
        - **Texto en negrita** para t√≠tulos importantes
        - `C√≥digo` para n√∫meros o datos clave
        - > Citas para destacar informaci√≥n
        - Listas con ‚Ä¢ o - para organizar datos
        
        **Per√≠odo del reporte:** {self._get_period_description(days)}
        
        Datos del reporte:
        - **üìä Total:** `{total_detections} detecciones` en `{days} d√≠as`
        {top_sounds}
        - {critical_info}
        - {main_recommendation}
        
        Da informaci√≥n pr√°ctica sobre:
        - Un dato importante del reporte
        - Una recomendaci√≥n √∫til
        - Un mensaje de apoyo
        
        **Al final, agrega un chiste o dato curioso** basado en los sonidos detectados:
        - Compara dos tipos de sonidos de forma divertida
        - Menciona algo curioso sobre el patr√≥n de sonidos
        - Haz una observaci√≥n amigable sobre el entorno
        - Usa emojis y mant√©n el tono positivo
        
        ¬°S√© positivo y alentador! üí™
        """

        return prompt

    def _get_period_description(self, days: int) -> str:
        """Genera una descripci√≥n amigable del per√≠odo del reporte"""
        if days == 1:
            return "**üìÖ Hoy**"
        elif days == 7:
            return "**üìÖ √öltima semana**"
        elif days == 30:
            return "**üìÖ √öltimo mes**"
        elif days == 90:
            return "**üìÖ √öltimos 3 meses**"
        elif days == 365:
            return "**üìÖ √öltimo a√±o**"
        else:
            return f"**üìÖ √öltimos {days} d√≠as**"

    def general_query_node(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Nodo para consultas generales"""
        try:
            from ..providers.text_generation.text_generator_manager import (
                text_generator_manager,
            )

            user_input = state.get("user_input", "")

            prompt = f"""
            Eres un amigable asistente que ayuda a personas con discapacidad auditiva.
            
            El usuario pregunta: "{user_input}"
            
            Responde de manera:
            - üéâ Alegre y motivadora
            - üìù Breve y f√°cil de entender
            - üíù Amigable y emp√°tica
            - ‚ú® Con emojis para hacerlo m√°s ameno
            
            Da informaci√≥n pr√°ctica sobre:
            - Un recurso √∫til para su pregunta
            - Un consejo amigable
            - Un mensaje de apoyo
            
            M√°ximo 3-4 l√≠neas. ¬°S√© positivo y alentador!
            """

            # Obtener el generador del estado o usar gemini por defecto
            generator = state.get("text_generator_model", "gemini")
            response = text_generator_manager.execute_generator(generator, prompt)
            state["response"] = response
            self._update_conversation_history(state, "GENERAL_QUERY")

            return state

        except Exception as e:
            self.logger.error(f"Error en general_query_node: {e}")
            state["response"] = (
                "¬°Ups! üòÖ No pude procesar tu consulta. ¬øMe lo preguntas de otra forma? üí™"
            )
            return state

    def _update_conversation_history(self, state: Dict[str, Any], detected_intent: str):
        """Actualiza el historial de conversaci√≥n"""
        user_input = state.get("user_input", "")
        response = state.get("response", "")

        # A√±adir mensajes al historial
        messages = state.get("messages", [])
        messages.append(HumanMessage(content=user_input))
        messages.append(AIMessage(content=response))
        state["messages"] = messages

        # Actualizar historial de conversaci√≥n
        conversation_history = state.get("conversation_history", [])
        conversation_history.append(
            {
                "user_input": user_input,
                "detected_intent": detected_intent,
                "response": response,
            }
        )
        state["conversation_history"] = conversation_history
